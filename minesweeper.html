<!DOCTYPE html>
<!--
Description: Single-file implementation of Mineseweeper with 10x10 gri, user-configurable mine count, and complete gameplay including mine flagging, recursive reveal, and win/loss detection.
Authors: Ted Athon, Alec Slavik, Dylan Oâ€™Brien, Divit Kannan, Nick Reinig, Amrit Sian
Creation Date: 9/2/2025
Course: EECS 581 Software Engineering II, Fall 2025

Inputs: User mouse clicks (left reveal, right flag), mine count selection via slider/number input
Outputs: Interactive game grid, status updates, win/loss detection notification
Source: Original, ChatGPT
-->
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Minesweeper 10x10 Grid</title>
<style>
  :root { --cell: 40px; }
  body { font-family: "Courier New", monospace; margin: 24px; }
  h1 { margin: 0 0 8px 0; }

  /* Controls */
  #controls {
    display: flex; gap: 12px; align-items: center; flex-wrap: wrap;
    margin: 8px 0 10px;
  }
  #controls label { font-weight: 700; }
  #controls input[type="number"] { width: 80px; padding: 4px 6px; }
  #controls button {
    padding: 6px 12px; border: 1px solid #333; background: #f4f4f4; cursor: pointer;
    border-radius: 6px;
  }
  #controls button:disabled { opacity: .6; cursor: not-allowed; }

  /* Status row */
  #status { margin: 6px 0 14px; }
  #state.playing { color: #0a7f00; font-weight: 700; }
  #state.lost { color: #b00000; font-weight: 700; }
  #state.won { color: #005fb0; font-weight: 700; }

  /* Board container with labels */
  #board-container {
    display: inline-block;
    margin-top: 6px;
  }

  /* Column labels */
  #column-labels {
    display: grid;
    grid-template-columns: var(--cell) repeat(10, var(--cell));
    gap: 2px;
    margin-bottom: 2px;
  }
  .column-label {
    width: var(--cell);
    height: 20px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: bold;
    font-size: 14px;
  }
  .column-label:first-child {
    /* Empty corner cell */
  }

  /* Game board with row labels */
  #game-board {
    display: grid;
    grid-template-columns: var(--cell) repeat(10, var(--cell));
    grid-template-rows: repeat(10, var(--cell));
    gap: 2px;
    width: max-content;
  }

  /* Row labels */
  .row-label {
    width: var(--cell);
    height: var(--cell);
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: bold;
    font-size: 14px;
  }

  /* Game cells */
  .cell {
    width: var(--cell); height: var(--cell);
    background: #ccc; border: 1px solid #999; cursor: pointer;
    display: flex; align-items: center; justify-content: center; user-select: none;
    font-weight: bold;
  }
  .cell.covered { background-color: #ccc; }
  .cell.revealed { background-color: #eee; cursor: default; }
  .cell.flagged { background-color: #cfd8ff; }
  .cell.flag-icon { color: red; font-size: 20px; }
  .cell.mine { background-color: #ffb3b3; color: black; }
  .cell:focus { outline: 2px solid black; }
</style>
</head>
<body>

<h1>Minesweeper 10x10 Grid</h1>

<!-- Control panel -->
<div id="controls">
  <label for="mineRange">Bombs:</label>
  <input id="mineRange" type="range" min="10" max="20" value="10">
  <input id="mineNumber" type="number" min="10" max="20" value="10">
  <button id="startBtn">Start Game</button>
  <button id="resetBtn" disabled>Reset</button>
  <label for="botSelect">Select Bot Difficulty</label>
  <select id="botSelect">
    <option value="singleplayer">N/A</option>
    <option value="easy">Easy</option>
    <option value="medium">Medium</option>
    <option value="hard">Hard</option>
  </select>
</div>

<div id="status">
  Status: <span id="state">Not started</span>
  | Mines: <span id="mines">0</span>
  | Flags left: <span id="flags">0</span>
</div>

<div id="board-container">
  <div id="column-labels"></div>
  <div id="game-board"></div>
</div>

<script>
/*
Description: Core game logic for Minesweeper with board management, mine placement, cell revealing, win/loss detection.
Source: Original, ChatGPT
/* === Config === */
const BOARD_SIZE = 10;                          // 10x10 fixed grid for now
const MAX_MINES = BOARD_SIZE * BOARD_SIZE - 1;  // keep at least 1 safe cell

/* === DOM === */
const board    = document.getElementById('game-board');
const columnLabels = document.getElementById('column-labels');
const minesEl  = document.getElementById('mines');
const flagsEl  = document.getElementById('flags');
const stateEl  = document.getElementById('state');
const startBtn = document.getElementById('startBtn');
const resetBtn = document.getElementById('resetBtn');
const mineRange  = document.getElementById('mineRange');
const mineNumber = document.getElementById('mineNumber');

/* Range/number bounds */
mineRange.max = 20; // max mines allowed
mineNumber.max = 20; // synchronizes slider and number input

/* === Game state === */
let minesTotal = 10; // total mines on board
let flagsPlaced = 0; // count of flags placed by user
let firstClick = true; // first click is safe
let minesPlaced = false; // track if mines are randomly placed
let gameOver = true; // game completion status
let revealedCount = 0; // number of safe cells revealed
let minePositions = new Set(); // storage for mine coordinates as strings
let botClicking;
let player_turn = 0;

/* === Helpers === */
// update game status display
function setStatus(text, cls='') {
  stateEl.textContent = text;
  stateEl.className = cls;
}
// update mine and flag counters in UI
function updateCounters() {
  minesEl.textContent = minesTotal;
  flagsEl.textContent = minesTotal - flagsPlaced; // remaining flags available
}

// checks if coordinates are within board boundaries
function isInBounds(r, c) {
  return r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE;
}
// generate string key for coordinate storage in set
function getKey(r, c){ return `${r},${c}`; }
// check if cell contains a mine
function isMine(r, c) { return minePositions.has(getKey(r,c)); }
// get DOM element for specific call
function getCell(r, c) {
  return document.querySelector(`.cell[data-row="${r}"][data-col="${c}"]`);
}
// count adjacent mines for number display
function countAdjacentMines(r, c) {
  let count = 0;
  // check all surrounding cells
  for (let dr = -1; dr <= 1; dr++) {
    for (let dc = -1; dc <= 1; dc++) {
      if (dr === 0 && dc === 0) continue; // skip center cell
      const nr = r + dr, nc = c + dc; // neighbor coordinates calculation
      if (isInBounds(nr, nc) && isMine(nr, nc)) count++;
    }
  }
  return count;
}

// randomly place mines on board avoiding first click location
function placeMines(excludeRow, excludeCol) {
  while (minePositions.size < minesTotal) {
    // generate random coordinate
    const r = Math.floor(Math.random() * BOARD_SIZE);
    const c = Math.floor(Math.random() * BOARD_SIZE);
    if (r === excludeRow && c === excludeCol) continue; // first click is safe
    minePositions.add(getKey(r, c)); // set handles duplicates automatically
  }
  minesPlaced = true;
}

// reveal all mine locations when game is over
function revealMines() {
  minePositions.forEach(key => {
    const [r,c] = key.split(',').map(Number); // parse coordinates from string
    const cell = getCell(r,c);
    if (!cell.classList.contains('revealed')) {
      cell.classList.remove('covered');
      cell.classList.add('revealed','mine');
      cell.textContent = 'ðŸ’£'; // visual indication of mine
    }
  });
}

/** Flood-fill reveal. Returns how many NEW cells were revealed. */
function floodReveal(startR, startC) {
  const stack = [[startR, startC]];
  const visited = new Set();
  let newlyRevealed = 0;

  while (stack.length) {
    const [r, c] = stack.pop();
    const key = getKey(r,c);
    if (visited.has(key) || !isInBounds(r,c) || isMine(r,c)) continue;
    visited.add(key);

    const cell = getCell(r, c);
    if (!cell || cell.classList.contains('revealed') || cell.classList.contains('flagged')) continue;

    cell.classList.remove('covered');
    cell.classList.add('revealed');
    newlyRevealed++;

    const adj = countAdjacentMines(r, c);
    cell.textContent = adj > 0 ? adj : '';

    if (adj === 0) {
      for (let dr = -1; dr <= 1; dr++) {
        for (let dc = -1; dc <= 1; dc++) {
          if (dr === 0 && dc === 0) continue;
          stack.push([r + dr, c + dc]);
        }
      }
    }
  }
  return newlyRevealed;
}

function checkWin() {
  const safeCells = BOARD_SIZE * BOARD_SIZE - minesTotal;
  if (revealedCount >= safeCells) {
    gameOver = true;
    setStatus('You won!', 'won');
    revealMines(); // optional: show where they were
  }
}

/* === Build Labels === */
function buildColumnLabels() {
  columnLabels.innerHTML = '';
  
  // empty corner cell
  const corner = document.createElement('div');
  corner.classList.add('column-label');
  columnLabels.appendChild(corner);
  
  // column labels A-J
  for (let i = 0; i < BOARD_SIZE; i++) {
    const label = document.createElement('div');
    label.classList.add('column-label');
    label.textContent = String.fromCharCode(65 + i); // A, B, C, etc.
    columnLabels.appendChild(label);
  }
}

/* === Build / Reset === */
function buildBoard() {
  player_turn = 0;
  board.innerHTML = '';
  buildColumnLabels();
  
  for (let row = 0; row < BOARD_SIZE; row++) {
    // add row label
    const rowLabel = document.createElement('div');
    rowLabel.classList.add('row-label');
    rowLabel.textContent = (row + 1).toString(); // 1, 2, 3 , etc
    board.appendChild(rowLabel);
    
    // add cells for this row
    for (let col = 0; col < BOARD_SIZE; col++) {
      const cell = document.createElement('div');
      cell.classList.add('cell','covered');
      cell.dataset.row = row;
      cell.dataset.col = col;
      cell.tabIndex = 0;

      // Left click (reveal)
      cell.addEventListener('click', () => {
        if (gameOver) return;
        if (cell.classList.contains('flagged') || !cell.classList.contains('covered')) return;

        if (firstClick && !minesPlaced) {
          placeMines(row, col);
          firstClick = false;
        }

        if (isMine(row, col)) {
          cell.classList.remove('covered');
          cell.classList.add('revealed','mine');
          cell.textContent = 'ðŸ’£';
          clearInterval(botClicking);
          gameOver = true;
          setStatus('Game over', 'lost');
          revealMines();
        } else {
          revealedCount += floodReveal(row, col);
          checkWin();
          cell.classList.remove('covered');
          cell.classList.add('revealed');
          player_turn++; // if all is working properly this should equal 1,3,5,7,9,... on users' clicks and vice versa for bots

          if (player_turn % 2 === 1) {
            setTimeout(botClick, 1000); // waits 1000ms, then bot takes turn
          }
        }
      });

      // Right click (flag)
      cell.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        if (gameOver) return;
        if (cell.classList.contains('revealed')) return;

        const add = !cell.classList.contains('flagged');
        if (add) {
          if (flagsPlaced >= minesTotal) return; // no more flags
          cell.classList.add('flagged','flag-icon');
          cell.textContent = 'âš‘';
          flagsPlaced++;
        } else {
          cell.classList.remove('flagged','flag-icon');
          cell.textContent = '';
          flagsPlaced--;
        }
        updateCounters();
      });

      board.appendChild(cell);
    }
  }
}

function startGame() {
  // sanitize mine count
  let m = parseInt(mineNumber.value, 10);
  if (isNaN(m) || m < 10) m = 10;
  if (m > 20) m = 20;
  mineRange.value = mineNumber.value = m;

  minesTotal   = m;
  flagsPlaced  = 0;
  firstClick   = true;
  minesPlaced  = false;
  gameOver     = false;
  revealedCount = 0;
  minePositions.clear();

  updateCounters();
  setStatus('Playing', 'playing');
  buildBoard();

  resetBtn.disabled = false;
}

function resetGame() {
  // keep same minesTotal; just rebuild fresh
  startGame();
}

function startBotGame() {
  startGame();
  const botDifficulty = document.getElementById("botSelect").value;
  if (botDifficulty == "easy") {
    botClicking = setInterval(easyBotClick, 500);
  }
  else if (botDifficulty == "medium") {
    botClicking = setInterval(mediumBotClick, 1000);
  }
}

function easyBotClick() {
    let randomRow = Math.floor(Math.random() * 10);
    let randomCol = Math.floor(Math.random() * 10);
    let cell = document.querySelector(`.cell.covered[data-row="${randomRow}"][data-col="${randomCol}"]`);
    if (cell) {
      console.log(`Bot clicks cell in row ${cell.dataset.row}, column ${cell.dataset.col}`);
      cell.click();
    }
    else {
      easyBotClick();
    }
}

function mediumBotClick() { 
  let revealed_cells = document.querySelectorAll('.cell.revealed');

  revealed_cells.forEach(cell => {
    if(cell.textContent != '') {
      console.log(`Bot CHECKS cell in row ${cell.dataset.row}, column ${cell.dataset.col}`);
      const row = parseInt(cell.dataset.row);
      const col = parseInt(cell.dataset.col);

      // Gets all neighbors
      let topLeft = document.querySelector(`.cell.covered[data-row="${row-1}"][data-col="${col-1}"]`);
      let topMid = document.querySelector(`.cell.covered[data-row="${row-1}"][data-col="${col}"]`);
      let topRight = document.querySelector(`.cell.covered[data-row="${row-1}"][data-col="${col+1}"]`);
      let midLeft = document.querySelector(`.cell.covered[data-row="${row}"][data-col="${col-1}"]`);
      let midRight = document.querySelector(`.cell.covered[data-row="${row}"][data-col="${col+1}"]`);
      let bottomLeft = document.querySelector(`.cell.covered[data-row="${row+1}"][data-col="${col-1}"]`);
      let bottomMid = document.querySelector(`.cell.covered[data-row="${row+1}"][data-col="${col}"]`);
      let bottomRight = document.querySelector(`.cell.covered[data-row="${row+1}"][data-col="${col+1}"]`);
      let neighbors = [topLeft, topMid, topRight, midLeft, midRight, bottomLeft, bottomMid, bottomRight];
      neighbors = neighbors.filter(neighbor => neighbor !== null);  // Filter out neighbors that aren't there

      // Rule 1: If the number of hidden neighbors of a revealed cell equals that cellâ€™s number
      if (neighbors.length == countAdjacentMines(row, col)) {
          neighbors.forEach((neighbor) => {
            console.log(`Bot FLAGS cell in row ${neighbor.dataset.row}, column ${neighbor.dataset.col} `)
            neighbor.classList.add('flagged','flag-icon');
            neighbor.textContent = 'âš‘'; // the AI should flag all hidden neighbors
        });
      }

      // Get flagged neighbors
      topLeft = document.querySelector(`.cell.covered.flagged.flag-icon[data-row="${row-1}"][data-col="${col-1}"]`);
      topMid = document.querySelector(`.cell.covered.flagged.flag-icon[data-row="${row-1}"][data-col="${col}"]`);
      topRight = document.querySelector(`.cell.covered.flagged.flag-icon[data-row="${row-1}"][data-col="${col+1}"]`);
      midLeft = document.querySelector(`.cell.covered.flagged.flag-icon[data-row="${row}"][data-col="${col-1}"]`);
      midRight = document.querySelector(`.cell.covered.flagged.flag-icon[data-row="${row}"][data-col="${col+1}"]`);
      bottomLeft = document.querySelector(`.cell.covered.flagged.flag-icon[data-row="${row+1}"][data-col="${col-1}"]`);
      bottomMid = document.querySelector(`.cell.covered.flagged.flag-icon[data-row="${row+1}"][data-col="${col}"]`);
      bottomRight = document.querySelector(`.cell.covered.flagged.flag-icon[data-row="${row+1}"][data-col="${col+1}"]`);
      neighbors = [topLeft, topMid, topRight, midLeft, midRight, bottomLeft, bottomMid, bottomRight];
      neighbors = neighbors.filter(neighbor => neighbor !== null);  // Filter out neighbors that aren't there

      // Rule 2: If the number of flagged neighbors of a revealed cell equals that cellâ€™s number
      if (neighbors.length == countAdjacentMines(row, col)) {
          neighbors.forEach((neighbor) => {
            console.log(`Bot CLICKS NEIGHBOR cell in row ${neighbor.dataset.row}, column ${neighbor.dataset.col}`);
            neighbor.click(); // the AI should open all other hidden neighbors
        });
      }
    }
  });

  //If no rule applies, the AI should pick a random hidden cell.
  easyBotClick();
}

// Disable clicking on board @TODO IMPLEMENT LATER WITH BOT PLAY MODE
function clickBoard(setting) {
  if (setting == "enable") {
    board.style = "";
  }
  else if (setting == "disable") {
    board.style = "pointer-events: none;"
  botClicking = setInterval(botClick, 500);
  //botClick();
}
}

function botClick() {
  const botDifficulty = document.getElementById("botSelect").value;
  console.log(botDifficulty);

  if (botDifficulty === "easy") {
    let randomRow = Math.floor(Math.random() * 10);
    let randomCol = Math.floor(Math.random() * 10);
    let cell = document.querySelector(`.cell.covered[data-row="${randomRow}"][data-col="${randomCol}"]`);
    if (cell && !cell.classList.contains("flagged")) {
        console.log(`Bot clicks cell in row ${cell.dataset.row}, column ${cell.dataset.col}`);
        cell.click();
    }
    else {
      botClick();
    }

  } else if (botDifficulty === "medium") {

  } else if (botDifficulty === "hard") { // hard difficulty
    //1st run flags, 2nd run checks for rule 2, random pick otherwise
    for (let row_index = 0; row_index < BOARD_SIZE; row_index++) {
      //if we cannot place anymore flags down, flagging run is pointless
      if (flagsPlaced >= minesTotal) break; // no more flags

      for (let column_index = 0; column_index < BOARD_SIZE; column_index++) {

        

        //Get tile with these coordinates
        let current_cell = getCell(row_index, column_index);

        //DEBUGGING, PLS REMOVE IF YOU DON'T NEED THE INFO
        //console.log(`current cell is row ${current_cell.dataset.row} column ${current_cell.dataset.col}`);

        //If this tile is not revealed yet, we can't check it -> skip
        if (!current_cell.classList.contains("revealed")) {
          continue;
        }

        //This section reachable iff tile is revealed

        //Check rule 1: if number of adjacent hidden tiles = revealed number, flag them all
        //Don't break from loop

        //Check rule 3: 121 rule
        //Don't break from loop
        //CONCEPT: only check the 121 rule a 2 tile
        //3.a: check for a 2 tile
        if (current_cell.textContent == '2') {
          //3.a.0 hopefully a bugfix for the case where there are more than 2 unrevealed corner squares around the 2
          // get all corner cells
          let up_left = getCell(row_index - 1, column_index - 1);
          let up_right = getCell(row_index - 1, column_index + 1);
          let down_left = getCell(row_index + 1, column_index - 1);
          let down_right = getCell(row_index + 1, column_index + 1);

          // count the number of unrevealed corners
          let unrevealed_corners = 0;
          if (up_left != null && !up_left.classList.contains("revealed")) {
            unrevealed_corners++;
          }
          if (up_right != null && !up_right.classList.contains("revealed")) {
            unrevealed_corners++;
          }
          if (down_left != null && !down_left.classList.contains("revealed")) {
            unrevealed_corners++;
          }
          if (down_right != null && !down_right.classList.contains("revealed")) {
            unrevealed_corners++;
          }
          if (unrevealed_corners > 2) {
            continue;
          }
          //3.b: get a + shape with the current_cell as the center, set 121 statuses to false
          let current_up_one = getCell(row_index - 1, column_index);
          let current_left_one = getCell(row_index, column_index - 1);
          let current_down_one = getCell(row_index + 1, column_index);
          let current_right_one = getCell(row_index, column_index + 1);
          let vertical_121 = false;
          let horizontal_121 = false;

          //3.c: check left and right exist and are revealed (check we aren't on the left or right bound of the grid)
          if ((current_left_one != null && current_right_one != null) && (current_left_one.classList.contains("revealed") && current_right_one.classList.contains("revealed"))) {

            //3.d check left and right tiles are 1s
            if (current_right_one.textContent == '1' && current_left_one.textContent == '1') {
              //DEBUGGING
              console.log(`horizontal 121 @ row ${current_cell.dataset.row} column ${current_cell.dataset.col}`);

              //indicate a 121 has been found
              horizontal_121 = true;
            }
          }

          //3.c: check up and down exist and are revealed (check we aren't on the top or bottom bound of the grid)
          if ((current_up_one != null && current_down_one != null) && (current_up_one.classList.contains("revealed") && current_down_one.classList.contains("revealed"))) {

            //3.d check left and right tiles are 1s
            if (current_up_one.textContent == '1' && current_down_one.textContent == '1') {
              //DEBUGGING
              console.log(`vertical 121 @ row ${current_cell.dataset.row} column ${current_cell.dataset.col}`);

              //indicate a 121 has been found
              vertical_121 = true;
            }
          }

          //3.e: if a 121 pattern has been detected flag the 4 corners of the 2
          if (vertical_121 || horizontal_121) {

            //get the 4 corners
            let current_tl = getCell(row_index - 1, column_index - 1);
            let current_tr = getCell(row_index - 1, column_index + 1);
            let current_bl = getCell(row_index + 1, column_index - 1);
            let current_br = getCell(row_index + 1, column_index + 1);

            //flag each corner if it exists, isn't revealed, and doesn't already contain a flag
            if (current_tl != null && !current_tl.classList.contains("revealed") && !current_tl.classList.contains('flagged')) {
              current_tl.classList.add('flagged','flag-icon');
              current_tl.textContent = 'âš‘';
              flagsPlaced++;
            }
            if (current_tr != null && !current_tr.classList.contains("revealed") && !current_tr.classList.contains('flagged')) {
              current_tr.classList.add('flagged','flag-icon');
              current_tr.textContent = 'âš‘';
              flagsPlaced++;
            }
            if (current_bl != null && !current_bl.classList.contains("revealed") && !current_bl.classList.contains('flagged')) {
              current_bl.classList.add('flagged','flag-icon');
              current_bl.textContent = 'âš‘';
              flagsPlaced++;
            }
            if (current_br != null && !current_br.classList.contains("revealed") && !current_br.classList.contains('flagged')) {
              current_br.classList.add('flagged','flag-icon');
              current_br.textContent = 'âš‘';
              flagsPlaced++;
            }

            //update flag counter
            updateCounters();


          }
        }
      }
    }

    //rule 2 run
    for (let row_index = 0; row_index < BOARD_SIZE; row_index++) {
      for (let column_index = 0; column_index < BOARD_SIZE; column_index++) {

        //Get tile with these coordinates
        let current_cell = getCell(row_index, column_index);

        //If this tile is not revealed yet, we can't check it -> skip
        if (!current_cell.classList.contains("revealed")) {
          continue;
        }

        //Check rule 2: if revealed number = number of adjacent flags, reveal unflagged hidden neighbors (if there are any)
          //return if done
      }
    }

    //random pick

  }
}

/* === Controls wiring === */
mineRange.addEventListener('input', () => {
  mineNumber.value = mineRange.value;
});
mineNumber.addEventListener('input', () => {
  let v = mineNumber.value;
  if (v === '') return; // allow typing
  if (+v > 20) v = 20;
  if (+v < 10) v = 10;
  mineNumber.value = v;
  mineRange.value = v;
});

startBtn.addEventListener('click', startGame);
resetBtn.addEventListener('click', resetGame);
startBotBtn.addEventListener('click', startBotGame);

/* Initial UI (no game running yet) */
setStatus('Not started');
updateCounters();
</script>
</body>
</html>

